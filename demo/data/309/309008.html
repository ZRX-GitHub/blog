<!DOCTYPE html>
<html>
<head>
<title>密码技术概述</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<link rel="shortcut icon" href="../../../img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="../../../css/nav-auto.css">
<link rel="stylesheet" href="../../../css/css.css">
<link rel="stylesheet" href="../../../css/markdownpad-github.css">
<link rel="stylesheet" href="../../../css/data-classify-auto.css">
</head>
	<body class="data_index">
		<div class="header">
			<div class="logo"><img src="../../../img/logo.png" alt=""></div>
			<div class="dropdown" id="dropdown">
				<div onclick="myFunction()" class="dropbtn"></div>
				<div id="myDropdown" class="dropdown-content">
					<div class="nav">		
						<a href="../../../index.html"><div class="ul" id="index">主页<div class="nav-line"></div></div></a>
						<a href="../../travel.html"><div class="ul" id="demo1">踏行<div class="nav-line"></div></div></a>
						<a href="../../data.html"><div class="ul" id="demo2">资料<div class="nav-line"></div></div></a>
						<a href="../../build.html"><div class="ul" id="demo3">建站<div class="nav-line"></div></div></a>
						<a href="../../about.html"><div class="ul" id="demo4">关于<div class="nav-line"></div></div></a>
					</div>
				</div>
			</div>	
		</div>
		<div id="main">
			<div class="nav-article">
				<span>当前所在位置：</span>
				<a href="../../data.html">资料</a>
				<span> &gt </span>
				<a href="XX">网络安全</a>
				<span> &gt </span>
				<a href="309008.html">密码技术概述</a>
			</div>
			<div class="data-classify-left">
				<div class="catalog"><p>目录</p>
					<div class="chapter"><a href="xx">简介</a></div> 
					<div class="chapterLine"></div>
					<div class="chapter"><a href="309008.html">密码技术概述</a></div> 	
					<div class="chapter" id="chapter-none"></div> 	
				</div>
			</div>
			<div class="data-classify-right">
				<div class="skip-top">
					<div class="previouPage"><a href="xx"> <img src="../../../img/arrow-left.png" alt=""> <span>简介</span></a></div>
					<div class="nextPage"><a href="xx"><span>XX</span> <img src="../../../img/arrow-right.png" alt=""> </a></div>
				</div>
				<div class="article">
				
					<!-- ↓  博客输入 ↓ -->
					<h1>密码技术概述</h1>
					<h2>1.密码技术的起源和历史</h2>
					<p>密码学的历史可大致划分为几个阶段：</p>
					<ul>
					<li>从古代到1949年为密码学诞生的前夜。这一阶段虽然有众多密码实践，比如两次世界大战中通信密码的大规模应用和密码的破译活动，但密码技术不是一种科学，而可称之为一种艺术。这一时期的密码专家常常靠直觉、猜测和信念来设计、分析密码，而不是凭借推理和证明；</li>
					<li>1949年，香农（Claude Shannon）在《贝尔系统技术杂志》上发表论文《保密系统的通信理论》，为对称密码系统奠定了理论基础，从而密码成为一门科学。而从1949年到1975年这段时间内，密码学的理论进展不大；</li>
					<li>直到1976年，Diffie和Hellman发表了《密码学的新方向》一文， 建立了公钥密码系统，引发了密码学上的一次革命性的变革。</li>
					</ul>
					<p>随着在密码学理论和技术上的探索和实践，人们逐渐认识到<strong>认证</strong>和<strong>保密</strong>是两个独立的密码属性。</p>
					<p>Simmons系统研究了认证问题，并建立了一套与香农保密理论平行的<strong>认证（Hash）理论</strong>。</p>
					<h2>2.对称密码</h2>
					<p>对称密码技术也叫做单钥或常规密码技术，包括分组密码技术和流密码技术这两个重要的分支。在公钥密码技术出现之前，它是唯一的加密类型。</p>
					<h2>2.1基本原理</h2>
					<p>对称密码必须满足如下要求：</p>
					<ul>
					<li>算法要足够强大。就是说，从截获的密文或某些已知明文密文对时，计算出密钥或明文是不可行的；</li>
					<li>不依赖于算法的保密，而依赖于密钥。这就是著名的Kerckhoff原则；</li>
					<li>正常加密和解密要快，破译越慢越好；</li>
					<li>密文相对明文最好无数据位扩展；</li>
					<li>好的加密算法要具有雪崩效应；</li>
					<li>好的加密算法的密文很难被压缩。</li>
					</ul>
					<h2>2.2 分组密码（Block Cipher）</h2>
					<p>分组密码是一个明文分组被作为一个整体来
					产生一个等长的密文分组的密码，通常使用的
					是64bit的分组大小。</p>
					<h2>2.2.1 常见的分组加密算法</h2>
					<h4>1. 数据加密标准DES</h4>
					<ul>
					<li>DES是一种对二元数据进行加密的算法，将明文消息分成64bit一组进行加密。密文分组的长度也是64bit，没有数据扩展。</li>
					<li>DES使用“密钥”进行加密，从符号的角度看，“密钥”的长度是64bit。</li>
					<li>但是由于某些原因，DES算法中每逢第8bit就被忽略，这造成密钥的实际大小为56bit。</li>
					</ul>
					<p><strong>DES的整个体制是公开的，系统的安全性完全
					依赖密钥的保密。</strong></p>
					<p><strong>DES算法主要包括</strong>：<br />
					<strong>1. 初始置换IP</strong>； <br />
					<strong>2. 16轮变换的乘积变换</strong>； <br />
					<strong>3. 逆初始置换IP-1</strong>；<br />
					<strong>4. 16个密钥产生器</strong>。</p>
					<p>在DES加密算法的一般描述的左边部分，可以
					看到明文的处理经过了3个阶段：</p>
					<ul>
					<li>64bit的明文经过一个初始置换IP后，比特重排产生经过置换的输出；</li>
					<li>由同一个函数的16次循环构成，这个函数本身既有置换又有替代功能；</li>
					<li>最后一个循环的输出由64bit组成，其输出的左边和右边两个部分经过交换后得到预输出；</li>
					<li>预输出通过逆初始置换IP-1生成64bit的密文。除了初始置换和逆初始置换之外，DES具有严格的Feistel密码结构。</li>
					</ul>
					<p><strong>右半部分</strong>给出了56bit密钥的使用方式：</p>
					<ul>
					<li>密钥首先通过一个置换函数，接着对于16个循环的每一个，都通过一个循环左移操作和一个置换操作的组合产生一个子密钥Ki；</li>
					<li>对于每一个循环来说，置换函数是相同的，但由于密钥比特的重复移动，产生的子密钥并不相同。</li>
					</ul>
					<p>DES的解密和加密使用相同的算法，只是将子密钥的使用次序反过来。</p>
					<p><strong>DES具有雪崩效应：明文或密钥1bit改变引起密文许多bit改变</strong>。如果密文的变化太小，就可能找到一种方法减小要搜索的明文和密钥空间。</p>
					<ul>
					<li>当密钥不变，明文产生1bit变化，在3次循环后，两个分组有21bit不同，而整个加密过程结束后，两个密文有34个位置不同；</li>
					<li>作为对比，明文不变，密钥发生1bit变化时，密文中有大约一半的bit不同。</li>
					</ul>
					<p><strong>DES算法可能有如下安全问题：</strong></p>
					<ul>
					<li><strong>DES的56位密钥太小</strong>。1998年7月，EFE宣布攻破了DES算法，他们使用的是不到25万美元的特殊的“DES破译机”，这种攻击只需要不到3天的时间；</li>
					<li><strong>DES的迭代次数可能太少</strong>（16次恰巧能抵抗差分分析）；</li>
					<li><strong>S盒（即替代函数S）中可能有不安全因素</strong>；</li>
					<li><strong>DES的一些关键部分不应当保密</strong>。</li>
					</ul>
					<p>在已知密文/明文对时，密钥搜索攻击就是简单地搜索所有可能的密钥；如果没有已知的密文/明文对时，攻击者必须自己识别明文，这是一个有相当难度的工作——<strong>单一性距离</strong>。</p>
					<ul>
					<li>如果报文是以普通英语写成的，可以使用程序自动完成英语的识别；</li>
					<li>如果明文报文在加密之前做过压缩，那么识别工作就更加困难；</li>
					<li>如果报文是某种更一般的类型，如二进制文件，那么问题就更加难以自动化。</li>
					</ul>
					<h4>单一性距离</h4>
					<p>可在其他事物中测定出所需的只含有合理明文的加密文本的数量。<br>
					1K等于6.8字节 &emsp; DES：8.2个字节  &emsp;  IDEA：19个字节</p>
					<ul>
					<li>如果明文含有一个格式的文件头，易识别；</li>
					<li>如果明文二进制（压缩文件），很难识别明文（即识别破解是否成功）。</li>
					</ul>
					<p>一次一密中，K趋向无穷大，单一性距离非常大，越大所以越难破解。</p>
					<h4>2. 三重DES</h4>
					<p>三重DES是人们在发现DES密钥过短，易于受到蛮力攻击而提出的一种替代加密算法。</p>
					<p>三重DES使用3个密钥，执行3次DES算法。加密过程为加密-解密-加密（<strong>EDE</strong>），可表示为如下的公式：<br>
					C=E <sub>K3</sub> (D <sub>K2</sub> (E <sub>K1</sub> (M)))</p>
					<p>为了避免三重DES使用3个密钥进行三阶段加密带来的密钥过长的缺点（168bit），Tuchman提出使用两个密钥的三重加密方法，这个方法只要求112bit密钥，即令其K1=K3：<br>
					<strong>C=E <sub>K1</sub> (D <sub>K2</sub> (E <sub>K1</sub> (M)))</strong></p>
					<p>三重DES的第二阶段的解密并没有密码编码学上的意义。它的唯一<strong>优点</strong>是<strong><em>可以使用三重DES解密原来的单次DES加密的数据</em></strong>，即K1=K2=K3。<br>
					C=E <sub>K1</sub> (D <sub>K1</sub> (E <sub>K1</sub> (M)))=E <sub>K1</sub> (M)</p>
					<h4>3. 国际数据加密算法IDEA</h4>
					<p>IDEA使用的是128bit密钥。IDEA与DES的明显区别在于循环函数和子密钥生成函数的不同。</p>
					<ul>
					<li>
					<p>对循环函数来说，<strong>IDEA不使用S盒子</strong>，而且IDEA依赖于3种不同的数学运算：</p>
					<ul>
					<li>XOR；</li>
					<li>16位整数的二进制加法；</li>
					<li>16位整数的二进制乘法。</li>
					</ul>
					</li>
					</ul>
					<p>&emsp;&emsp;这些转换很难分析，也很难进行密码分析。</p>
					<ul>
					<li>子密钥生成算法完全依赖于循环移位的使用，但使用方式复杂，对IDEA的8个循环中的每一个都会生成6个子密钥。</li>
					</ul>
					<p>IDEA算法有如下<strong>优点</strong>：</p>
					<ul>
					<li>加密速度快；</li>
					<li>密钥产生简单；</li>
					<li>用软硬件都能实现。</li>
					</ul>
					<p>IDEA是最早的128bit替换中的一个，已经经历了大量详细的审查，其安全性主要体现在：</p>
					<ul>
					<li>穷举搜索破译，要求进行2128约为1038次尝试，对每秒完成100万次加密的机器，需要10<sup>13</sup>年；</li>
					<li><strong>能抗差分分析和相关分析攻击</strong>；</li>
					<li><strong>没有DES意义下的弱密钥</strong>，但仍然有251个弱密钥。</li>
					</ul>
					<h4>4. 高级加密标准AES</h4>
					<ul>
					<li>AES的基本要求是，比三重DES快而且至少和三重DES一样安全；</li>
					<li>AES分组长度为128bit，密钥长度为128/192/ 256bit。</li>
					</ul>
					<p><strong>Rijndael算法</strong>是一种分组长度和密钥长度均可变的分组密码算法，其分组长度和密码长度都分别可为128/192/256bit。一般说来， Rijndael汇聚了<strong>安全<strong>、</strong>效率</strong>、<strong>简单</strong>、<strong>灵活<strong>等优点，使它能成为</strong>AES最合适的选择</strong>。</p>
					<ul>
					<li>安全性： Rijndael算法抗线性攻击和抗差分攻击的能力大大增强。没有比穷举更有效的攻击方法；</li>
					<li>算法的速度：RC6需要用到乘法运算，并且需要大量内存；Twofish不便于在硬件中实现；Mars和Serpent的速度都不如Rijndael；</li>
					<li>灵活性： Rijndael的密钥长度可根据不同的加密级别进行选择。 Rijndael的分组长度也是可变的，弥补了DES的弊端。 Rijndael的循环次数允许在一定范围内根据安全要求进行修正。</li>
					</ul>
					<h4>2.2.2 分组加密算法对比</h4>
					<table>
					<thead>
					<tr>
						<th align="center">算法</th>
						<th align="center">密钥长度</th>
						<th align="center">分组长度</th>
						<th>循环次数</th>
					</tr>
					</thead>
					<tbody>
					<tr>
						<td align="center">DES</td>
						<td align="center">56</td>
						<td align="center">64</td>
						<td>16</td>
					</tr>
					<tr>
						<td align="center">三重DES</td>
						<td align="center">112/168</td>
						<td align="center">64</td>
						<td><strong>48</strong></td>
					</tr>
					<tr>
						<td align="center">IDEA</td>
						<td align="center">128</td>
						<td align="center">64</td>
						<td>8</td>
					</tr>
					<tr>
						<td align="center">AES</td>
						<td align="center">128/192/256</td>
						<td align="center">128/192/256</td>
						<td>10/12/14</td>
					</tr>
					</tbody>
					</table>
					<h4>2.3 流密码（是通信双方事先共享的，可重复）</h4>
					<p>流密码是密码体制中的一个重要分支。20世纪50年代，数字电子技术的发展使<strong>密钥可以方便地利用移位寄存器为基础的电路来产生</strong>，这促使线性和非线性移位寄存器理论迅速发展。</p>
					<p><strong>流密码</strong>一直是作为 <strong>军事</strong> 和 <strong>外交场合</strong> 使用的主要密码技术。通常情况下，流密码总是以明文的位作为加密的单位。</p>
					<p>密钥流生成器（硬件的）将一个短的随机Key值扩展为一个长得多的伪随机序列，使得与真随机序列在计算上不可区分，以替换对真随机Key流的需求，同时又能满足计算上的安全性。&emsp;&emsp;——与一次一密的异同</p>
					<ul>
					<li>有效的数学工具，如<strong>代数和谱分析理论的引入</strong>，使得流密码理论迅速发展和走向较成熟的阶段；</li>
					<li>同时由于<strong>实现简单、速度快、没有或只有有限的错误传播</strong>，使流密码在实际应用中，特别是在专用和机密机构中仍保持优势；</li>
					<li>目前已提出多种类型的流密码，但<strong>大多是以硬件实现的专用算法，尚无标准化的流密码算法</strong>。</li>
					</ul>
					<p><strong>加密和解密过程</strong></p>
					<ul>
					<li><strong>加密时，将一段类似于噪声的伪随机序列与明文序列模2加后作为密文序列，这样即使对于一段全“0”或全“1”的明文序列，经过流密码加密后也会变成类似于随机噪声的乱数流</strong>；</li>
					<li><strong>在接收端，用相同的随机序列与密文序列模2加便可恢复明文序列</strong>；</li>
					<li><strong>保持收发两端密钥的精确同步是实现可靠解密的关键技术</strong>。</li>
					</ul>
					<h4>2.3.2 RC-4</h4>
					<p>RC-4是由RSA公司的Rivest在1987年提出的<strong>密钥长度可变流密码</strong>。它对差分攻击和线性分析具有免疫力，没有短循环，且具有高度非线性，尚无公开的分析结果。它大约有2<sup>1700</sup>个可能的状态。</p>
					<h2>3.公钥密码（基于单向陷门函数）</h2>
					<p>公钥密码技术是在试图解决常规加密面临的两个最突出问题：密钥分配和数字签名的过程中发展起来的。</p>
					<ul>
					<li>1976年，Diffie和Hellman创造性地提出了公开密码体制；</li>
					<li>这一体制的最大特点是采用两个密钥将加密和解密分开：一个公开作为加密密钥，叫做公钥；一个为用户专用，作为解密密钥，叫做私钥；</li>
					<li>要从公钥和密文分析出明文或私钥，在计算上是不可行的。</li>
					</ul>
					<h4>3.2.2 RSA算法</h4>
					<p>RSA公钥密码算法是目前因特网上进行保密通信和数字签名的最有效的安全算法之一。 <strong>RSA算法的安全性基于数论中大素数分解的困难性</strong>，所以RSA需采用足够大的素数。因子分解越困难，密码就越难破译，安全强度越高。但学上至今还未证明因子分解就是攻击RSA的最佳方法，也未证明分解大整数就是NP问题，可能有尚未发现的多项式时间分解算法。  统计数据表明，在重要应用中，需要采用1024bit的密钥，在SET协议中要采用2048bit的密钥。</p>
					<p>RSA加密比DES加密至少要慢100倍。</p>
					<h4>3.2.3 椭圆曲线密码技术ECC</h4>
					<p><strong>ECC的依据就是定义在椭圆曲线点群上的离散对数问题的难解性。椭圆曲线公钥系统是替代RSA的强有力的竞争者</strong>。</p>
					<p>椭圆曲线加密方法与RSA方法相比，有下述<strong>优点</strong>：</p>
					<ul>
					<li><strong>安全性能更高</strong>；</li>
					<li><strong>计算量小，处理速度快</strong>（<em>密钥短得多</em>）；</li>
					<li><strong>存储空间占用小和带宽要求低等</strong>。</li>
					</ul>
					<p>ECC的这些特点使它必然取代RSA，成为通用的公钥加密算法。比如，SET协议的制定者已把它作为下一代SET协议中缺省的公钥密码算法。</p>
					<table>
					<thead>
					<tr>
						<th align="center">算法</th>
						<th align="center">密钥交换</th>
						<th align="center">加密/解密</th>
						<th>数字签名</th>
					</tr>
					</thead>
					<tbody>
					<tr>
						<td align="center">Diffie-Hellman</td>
						<td align="center">是</td>
						<td align="center">否</td>
						<td>否</td>
					</tr>
					<tr>
						<td align="center">数字签名(DSS)</td>
						<td align="center">否</td>
						<td align="center">否</td>
						<td>是</td>
					</tr>
					<tr>
						<td align="center">RSA</td>
						<td align="center">是</td>
						<td align="center">是</td>
						<td>是</td>
					</tr>
					<tr>
						<td align="center">椭圆曲线(ECC)</td>
						<td align="center">是</td>
						<td align="center">是</td>
						<td>是</td>
					</tr>
					</tbody>
					</table>
					<h4>3.3 公钥密码、对称密码技术比较</h4>
					<h6>3.3.1 对称密码技术特点</h6>
					<p>优点：</p>
					<ul>
					<li>运算简单</li>
					<li>易于实现</li>
					<li>占用资源少</li>
					<li>加密速度快</li>
					</ul>
					<p>缺点：</p>
					<ul>
					<li>进行安全通信前要以安全方式进行密钥交换，这在互联网环境下非常困难；</li>
					<li>密钥规模非常大：N个用户两两进行相互通信，对每个用户需要维护N-1个密钥，总共需要(N-1)N/2个密钥。密钥管理困难。</li>
					</ul>
					<h6>3.3.2 公开密码技术特点</h6>
					<p>优点：</p>
					<ul>
					<li>通信双方事先不需要通过保密信道交换密钥；</li>
					<li>密钥持有量大大减少。N个用户两两相互通信只需要拥有N对密钥（每个用户一对密钥）；</li>
					<li>公开密码技术还提供了对称密码技术无法或很难提供的服务，如与Hash函数联合运行可生成数字签名。</li>
					</ul>
					<p>缺点：</p>
					<ul>
					<li>大量的浮点运算致使计算量大，加密/解密速度慢，需占用较多资源，对于电子商务活动尤为突出。</li>
					</ul>
					<h6>3.3.3 对称密码、公开密码的综合应用</h6>
					<p>在实际应用中，并不直接使用公开加密算法加密明文，而仅用它保护实际用于加密明文的对称密钥，即所谓的<strong>数字信封技术</strong>。使用这种方式，用户可以在每次发送保密信息时都使用不同的对称密钥，从而增加密码破译的难度。一次密码的破译不影响其他传递。</p>
					<h2>4.消息验证和数字签名</h2>
					<p>消息验证和数字签名技术是防止主动攻击的重要技术。</p>
					<h4>4.1 消息验证</h4>
					<ul>
					<li><strong>消息加密</strong>：以整个消息的密文作为它的验证码；</li>
					<li><strong>消息验证码(MAC)</strong>：以一个公开函数和一个密钥作用于消息，产生一个定长数据分组，即消息验证码，并将其附加在报文中；</li>
					<li><strong>散列函数</strong>：一个将任意长度的消息映射为定长的散列值的公开函数，以散列值作为验证码。</li>
					</ul>
					<h6>4.1.1 消息验证码</h6>
					<p>在这种技术中，通信双方共享一个密钥K。如果A有消息要送给B，他就会计算出消息的验证码，它是消息和密钥的函数：<br>MAC<sub>M</sub>=F(K,M)。<br> <strong>消息和验证码被传送给接收方</strong>，接收方对接收到的消息进行同样的计算，并将接收的验证码与计算出的验证码相比较。</p>
					<p>如果接收方和发送方知道密钥，而且接收的验证码与计算出的验证码相等，则：</p>
					<ul>
					<li><strong>接收方能够确信消息没有被改动</strong>。如果攻击者改动了消息，但没有改动验证码，则接收方计算出的验证码就会与收到的验证码不同。因为攻击者不知道保密密钥，所以攻击者也就不能按消息中的改动相应地改动验证码；</li>
					<li><strong>接收方能够确信消息确实来自其声称的来源</strong>。因为没有其他人知道密码，所以也没有人能够用正确的验证码来伪造消息；</li>
					<li><strong>如果消息包含了序列号，则接收方就能够确信序列是正确的</strong>，因为攻击者不能成功地改动序列号。</li>
					</ul>
					<h6>4.1.2 散列函数</h6>
					<p>散列值由如下形式的函数产生：
					<br>h=H(M)<br></p>
					<p>当确信或已知消息正确时，散列值在发送方被加到消息上。接收方通过重算那个消息的散列值来验证该消息。<strong>散列函数H必须具有性质</strong>：</p>
					<ul>
					<li>H能用于任何长度的数据分组；</li>
					<li>H产生定长的输出；</li>
					<li>对任何给定的x，H(x)要相对容易计算；</li>
					<li>对任何给定的码h，寻找x使得H(x)=h在计算上 是不可行的，称为单向性；</li>
					<li>对任何给定的分组x，寻找不等于x的y，使得H(y)=H(x)在计算上是不可行的，称为弱抗冲突（Weak Collision Resistance）；(<strong>有意义</strong>)</li>
					<li>寻找对任何的(x,y)对，使得H(y)=H(x)在计算上  是不可行的，称为强抗冲突（Strong Collision  Resistance）。(抗生日攻击)</li>
					</ul>
					<p>HMAC<sub>M</sub>=Hash(K,M)</p>
					<p>不需要密钥就能求出散列值，但HMAC算法是需要密钥的，并可与多种散列算法结合。如HMAC-MD5和HMAC-SHA-1。最新研究表明，<strong>MD5散列算法已不安全，必须向SHA-1转换</strong>。</p>
					<p><strong>对散列函数最直接攻击是字典(蛮力)匹配攻击</strong>。</p>
					<ul>
					<li>
					<p>MD5</p>
					<ul>
					<li>由Ron Rivest提出，MD5是使用最普遍的安全散列算法；</li>
					<li>该算法以一个任意长的消息作为输入，生成128 bit的消息摘要输出。输入按512 bit分组；</li>
					<li>随着处理器速度的提升，128bit散列值的安全性已经成为问题；</li>
					<li>可以看出，具有相同数字摘要的两个消息的处理需要2<sup>64</sup>次操作，而给定摘要寻找消息需要2<sup>128</sup>次操作。前一个数字太小了，不能够保证安全。</li>
					</ul>
					</li>
					<li>
					<p>SHA-1</p>
					</li>
					</ul>
					<p>&emsp;SHA由NIST提出，并在1995年推出了改进版本SHA-1。该算法输入消息的最大长度不超过264bit，输出一个160bit的消息摘要。输入按512bit分组进行处理。</p>
					<p>&emsp;SHA-1的每位散列值都是输入位的函数，具有良好的雪崩效应。SHA-1摘要比MD5摘要长32位， SHA-1要比MD5安全：</p>
					<ul>
					<li>
					<ul>
					<li>对蛮力攻击，产生与给定报文摘要相同摘要的报文难度对于MD5是2<sup>128</sup>、对于SHA-1是2<sup>160</sup>数量级；</li>
					<li>而产生摘要相同的两个报文的难度对MD5是2<sup>64</sup>、对于SHA-1是2<sup>80</sup>数量级。</li>
					</ul>
					</li>
					<li>
					<p>RIPEMD-160</p>
					</li>
					</ul>
					<p>它是RIPE项目开发的，最初开发的是128bit RIPEMD。在RIPE项目结束后，Dobbertin发现了对RIPEMD两个循环的攻击方法，后来又发现了对MD4和MD5攻击方法。因此RIPE的一些成员决定更新RIPEMD为RIPEMD-160。 RIPEMD-160的结与SHA-1非常相似，也生成160bit的消息摘要。</p>
					<h4>4.2 数字签名</h4>
					<p>最吸引人的解决方案是<strong>数字签名</strong>，<em>有如下性质</em>：</p>
					<ul>
					<li>必须能够证实是作者本人的签名以及签名的日期和时间；</li>
					<li>在签名时必须能够对内容进行鉴别；</li>
					<li>签名必须能被第三方证实以便解决争端。</li>
					</ul>
					<p><strong>数字签名与消息加密有所不同</strong>：</p>
					<ul>
					<li>消息加密和解密可能是一次性的，它只要求在解密之前是安全的；</li>
					<li>而一个签名的消息可能会作为一个法律上的文件，很可能在对消息签署多年以后才验证其签名，且可能需要多次验证此签名。</li>
					</ul>
					<p>因此，<strong>对签名的安全性和防伪造要求更高，并且要求验证速度比签名速度要快，特别是联机在线实时验证</strong>。</p>
					<h6>4.2.1 RSA签名体制 ######]</h6>
					<p><strong>签名过程</strong>：</p>
					<ul>
					<li>把需要签名的消息M作为一个散列函数的输入，由此输出一个定长的安全散列码；</li>
					<li>发送方用自己的私钥KRa将这个散列码进行加密就形成签名；</li>
					<li>此后，将消息M和签名传送出去。</li>
					</ul>
					<p><strong>验证过程</strong>：</p>
					<ul>
					<li>接收方接受到消息M，根据消息M计算一个散列码，同时使用发送方的公钥对签名解密。</li>
					<li>若解密后的散列码与计算得出的散列码一致，则签名是有效的。</li>
					</ul>
					<h6>4.2.2 数字签名标准</h6>
					<p>NIST已经公布所谓的数字签名标准（DSS）。DSS利用前面介绍的安全散列算法（SHA）并提出了一种新的数字签名技术，即数字签名算法（DSA）。</p>
					<p>DSS是一种基于公开密钥技术的算法，是用来提供唯一的数字签名函数。与RSA不同，它不能用作加密或密钥交换。</p>
					<p><strong>量子密码</strong></p>
					<p>某种程度上是一次一密思想的一个变体。</p>
					<ul>
					<li>为实现量子密码，我们需要随机但可检测方向的光源（发送者使用的光子枪），和很可靠地过滤接收到光子的方法；</li>
					<li>超过20km的可靠通信已经成功迈向50km；</li>
					<li>20年商业使用，有可能走在量子计算机的前面。</li>
					</ul>
					
				</div>
				<!--  ↑ 博客输入  ↑ -->
				
				<div class="skip-bottom">
					<div class="previouPage"><a href="XX"> <img src="../../../img/arrow-left.png" alt=""> <span>XX</span></a></div>
					<div class="nextPage"><a href="XX"><span>XX</span> <img src="../../../img/arrow-right.png" alt=""> </a></div>
				</div>
			</div>
		</div>
		<button onclick="topFunction()" id="myBtn" title="返回顶部"></button>
		<footer>
			<p>Design by Simple</p>
			<p>本网站依托于github建立，源代码已开源。</p>
			<p>联系方式②：<a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=A3lxe2ZuYmpvQ3Vqcy1yci1gbG4&subject=blog" style="text-decoration:none;">zrxemail@vip.qq.com</a></p>
		</footer>	
		<script src="../../../js/js.js" type="text/javascript"></script>
	</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
